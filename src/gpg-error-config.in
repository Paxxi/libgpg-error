#!/bin/sh
# Copyright (C) 1999, 2002, 2003 Free Software Foundation, Inc.
#
# This file is free software; as a special exception the author gives
# unlimited permission to copy and/or distribute it, with or without
# modifications, as long as this notice is preserved.
#
# This file is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# SPDX-License-Identifier: FSFULLR

prefix=@prefix@
datarootdir=@datarootdir@
datadir=@datadir@
PKG_CONFIG_PATH="$PKG_CONFIG_PATH${PKG_CONFIG_PATH:+:}${datadir}/pkgconfig"
#

#### start of pkgconf-funcs

#
# Bourne shell functions for config file in pkg-config style, so that
# we can share such a config file between pkg-config and script
#

#
# get_var: Get the variable value of NAME
#
# Variables are recorded in the shell variables named "VAR_<NAME>"
#
get_var () {
    local name=$1

    eval echo \$VAR_$name
}

#
# get_attr: Get the attribute value of KEY
#
# Attributes are recorded in the shell variables named "ATTR_<KEY>"
#
get_attr () {
    local name=$1

    eval echo \$ATTR_$name
}

# Remove ${varname} part in the beginning of a string.
remove_var_expr () {
    local varname=$1
    shift

    eval echo \"\${@#\\\$\\\{$varname\\\}}\"
}

# Given a string, substitute variables.
substitute_vars () {
    local string="$1"
    local line
    local varname
    local result

    while [ -n "$string" ]; do
	case "$string" in
	    \$\$*)
		result="$result\$"
		string="${string#\$\$}"
		;;
	    \${*}*)
		varname="${string#\$\{}"
		varname="${varname%%\}*}"
		result="$result$(get_var ${varname})"
		string=$(remove_var_expr ${varname} ${string})
		;;
	    *)
		result="${result}$(printf %c "$string")"
		string="${string#$(printf %c "$string")}"
		;;
	esac
    done

    echo "$result"
}

#
# Read a config from stdin
#
# Variables:
# For VAR=VALUE, value is stored in the shell variable VAR_*.
#
# Attributes:
# For KEY: VALUE, value is stored in the shell variable ATTR_*.
#
read_config_from_stdin () {
    local line
    local varname
    local value
    local key

    while read line; do
	case "$line" in
	    *=*)
		varname="${line%%=*}"
		value="${line#*=}"
		VAR_list="$VAR_list VAR_$varname"
		read VAR_$varname <<EOF1
$(substitute_vars "$value")
EOF1
		;;
	    *:\ *)
		key="${line%%:\ *}"
		value="${line#*:\ }"
		ATTR_list="$ATTR_list ATTR_$key"
		read ATTR_$key <<EOF2
$(substitute_vars "$value")
EOF2
		;;
	esac
    done
}


find_file_in_path () {
    local f=$1
    local p=$2
    local IFS=":"		# On Windows it should be ";"???

    for d in $p; do
	if [ -r $d/$f ]; then
	    RESULT="$d/$f"
	    return 0
	fi
    done
    RESULT=""
    return 1
}

read_config_file () {
    local config_file
    local RESULT

    if find_file_in_path $1.pc $2; then
	config_file=$RESULT
    else
	echo "Can't find $1.pc" 1>&2
	exit 1
    fi
    read_config_from_stdin < $config_file
}

cleanup_vars_attrs () {
    eval unset $VAR_list VAR_list
    eval unset $ATTR_list ATTR_list
}

not_listed_yet () {
    local m=$1
    local arg
    shift

    for arg; do
	if [ $m = $arg ]; then
	    return 1
	fi
    done

    return 0
}

list_only_once () {
    local result=""
    local arg

    for arg; do
	if not_listed_yet $arg $result; then
	    result="$result $arg"
	fi
    done

    echo $result
}

list_only_once_for_libs () {
    local result=""
    local rev_list=""
    local arg

    # Scan the list and eliminate duplicates for non-"-lxxx"
    # the resulted list is in reverse order
    for arg; do
	case "$arg" in
	    -l*)
		# As-is
		rev_list="$arg $rev_list"
		;;
	    *)
		if not_listed_yet $arg $rev_list; then
		    rev_list="$arg $rev_list"
		fi
		;;
	esac
    done

    # Scan again
    for arg in $rev_list; do
	case "$arg" in
	    -l*)
		if not_listed_yet $arg $result; then
		    result="$arg $result"
		fi
		;;
	    *)
		# As-is
		result="$arg $result"
		;;
	esac
    done

    echo $result
}

#
# Recursively solve package dependencies
#
# XXX: version requirement (version comparison) is not yet supported
#
all_required_config_files () {
    local list
    local all_list
    local new_list
    local p

    list="$@"
    all_list="$list"

    while [ -n "$list" ]; do
	new_list=""
	for p in $list; do
	    read_config_file $p $PKG_CONFIG_PATH
	    new_list="$new_list $(get_attr Requires)"
	    cleanup_vars_attrs
	done
	all_list="$all_list $new_list"
	list="$new_list"
    done

    echo $(list_only_once $all_list)
}

#### end of pkgconf-funcs

myname=${0##*/}
if [ $myname = gpgrt-config ]; then
  myname="gpg-error-config"
fi

usage()
{
    cat <<EOF
Usage: $myname [OPTIONS]
Options:
        [--mt]       (must be the first option)
	[--prefix]
	[--exec-prefix]
	[--version]
	[--libs]
	[--cflags]
EOF
    exit $1
}

if test $# -eq 0; then
    usage 1 1>&2
fi

if [ "$1" != "--mt" ]; then
    mt=no
else
    # In future, use --variable=mtcflags or --variable=mtlibs
    mt=yes
    shift
fi

modules=""
output_var=""
output_attr=""
opt_cflags=no
opt_libs=no
output=""
delimiter=" "

while test $# -gt 0; do
    case $1 in
	--prefix)
	    # In future, use --variable=prefix instead.
	    output_var=prefix
	    ;;
	--exec-prefix)
	    # In future, use --variable=exec_prefix instead.
	    output_var=exec_prefix
	    ;;
	--version)
	    # In future, use --modversion instead.
	    output_attr=Version
	    delimiter="
"
	    ;;
	--modversion)
	    output_attr=Version
	    delimiter="
"
	    ;;
	--cflags)
	    opt_cflags=yes
	    ;;
	--libs)
	    opt_libs=yes
	    ;;
	--variable=*)
	    output_var=${1#*=}
	    ;;
	--host)
	    # In future, use --variable=host instead.
	    output_var=host
	    ;;
	--help)
	    usage 0
	    ;;
	*)
	    modules="$modules $1"
	    ;;
    esac
    shift
done

if [ $myname = "gpg-error-config" -a -z "$modules" ]; then
    read_config_file ${myname%-config} $PKG_CONFIG_PATH
    if [ -n "$output_var" ]; then
	output="$output${output:+ }$(get_var $output_var)"
    elif [ -n "$output_attr" ]; then
	output="$output${output:+ }$(get_attr $output_attr)"
    else
	cflags="$(get_attr Cflags)"
	libs="$(get_attr Libs)"

	mtcflags="$(get_var mtcflags)"
	mtlibs="$(get_var mtlibs)"
    fi

    requires="$(get_attr Requires)"
    cleanup_vars_attrs
    pkg_list=$(all_required_config_files $requires)
else
    if [ -z "$modules" ]; then
	modules=${myname%-config}
    fi
    cflags=""
    libs=""
    pkg_list=$(all_required_config_files $modules)
fi

for p in $pkg_list; do
    read_config_file $p $PKG_CONFIG_PATH
    if [ -n "$output_var" ]; then
	output="$output${output:+$delimiter}$(get_var $output_var)"
    elif [ -n "$output_attr" ]; then
	output="$output${output:+$delimiter}$(get_attr $output_attr)"
    else
	cflags="$cflags${cflags:+ }$(get_attr Cflags)"
	libs="$libs${libs:+ }$(get_attr Libs)"
    fi
    cleanup_vars_attrs
done

if [ -z "$output_var" -a -z "$output_attr" ]; then
    if [ $opt_cflags = yes ]; then
	output="$output $(list_only_once $cflags)"
	# Backward compatibility to old gpg-error-config
	if [ $mt = yes ]; then
	    output="$output $mtcflags"
	fi
    fi
    if [ $opt_libs = yes ]; then
	output="$output $(list_only_once_for_libs $libs)"
	# Backward compatibility to old gpg-error-config
	if [ $mt = yes ]; then
	    output="$output $mtlibs"
	fi
    fi
fi

echo "$output"
